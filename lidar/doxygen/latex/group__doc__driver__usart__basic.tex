\hypertarget{group__doc__driver__usart__basic}{}\doxysection{USART Basic}
\label{group__doc__driver__usart__basic}\index{USART Basic@{USART Basic}}


Driver for basic USART functionality.  


\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int8\+\_\+t \mbox{\hyperlink{group__doc__driver__usart__basic_gad3a251bba1a79346b1c27d3301767fc4}{USART\+\_\+0\+\_\+init}} ()
\begin{DoxyCompactList}\small\item\em Initialize USART interface If module is configured to disabled state, the clock to the USART is disabled if this is supported by the device\textquotesingle{}s clock system. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__doc__driver__usart__basic_ga2e9797ff138959ac3d036b53138b7614}{USART\+\_\+0\+\_\+enable}} ()
\begin{DoxyCompactList}\small\item\em Enable RX and TX in USART\+\_\+0. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__doc__driver__usart__basic_gaa511a2829531e83a6b8a2d9f4d92cd4d}{USART\+\_\+0\+\_\+enable\+\_\+rx}} ()
\begin{DoxyCompactList}\small\item\em Enable RX in USART\+\_\+0. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__doc__driver__usart__basic_ga79b9d691565110f7852ceeaf4e4ae935}{USART\+\_\+0\+\_\+enable\+\_\+tx}} ()
\begin{DoxyCompactList}\small\item\em Enable TX in USART\+\_\+0. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__doc__driver__usart__basic_gacb4743093fced48085f08be8475a110a}{USART\+\_\+0\+\_\+disable}} ()
\begin{DoxyCompactList}\small\item\em Disable USART\+\_\+0. \end{DoxyCompactList}\item 
uint8\+\_\+t \mbox{\hyperlink{group__doc__driver__usart__basic_gac97a6770dcebe99ef4c8014c88d1bae2}{USART\+\_\+0\+\_\+get\+\_\+data}} ()
\begin{DoxyCompactList}\small\item\em Get recieved data from USART\+\_\+0. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{group__doc__driver__usart__basic_gac3a937c744dab16200ee8db359f49080}{USART\+\_\+0\+\_\+is\+\_\+tx\+\_\+ready}} ()
\begin{DoxyCompactList}\small\item\em Check if the usart can accept data to be transmitted. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{group__doc__driver__usart__basic_ga8389bcb949d1ff820c139bbda0f9abf6}{USART\+\_\+0\+\_\+is\+\_\+rx\+\_\+ready}} ()
\begin{DoxyCompactList}\small\item\em Check if the USART has received data. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{group__doc__driver__usart__basic_ga97b8ccb4de88c69e8f128d05aacf3020}{USART\+\_\+0\+\_\+is\+\_\+tx\+\_\+busy}} ()
\begin{DoxyCompactList}\small\item\em Check if USART\+\_\+0 data is transmitted. \end{DoxyCompactList}\item 
uint8\+\_\+t \mbox{\hyperlink{group__doc__driver__usart__basic_ga52609b48c1fa65ca905d8cb91d641e13}{USART\+\_\+0\+\_\+read}} ()
\begin{DoxyCompactList}\small\item\em Read one character from USART\+\_\+0. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{group__doc__driver__usart__basic_gac62803942950806dd1663834efd2448d}{USART\+\_\+0\+\_\+write}} (const uint8\+\_\+t data)
\begin{DoxyCompactList}\small\item\em Write one character to USART\+\_\+0. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Driver for basic USART functionality. 

\hypertarget{group__doc__driver__usart__basic_doc_driver_usart_basic_rev}{}\doxysubsection{Revision History}\label{group__doc__driver__usart__basic_doc_driver_usart_basic_rev}

\begin{DoxyItemize}
\item v0.\+0.\+0.\+1 Initial Commit
\end{DoxyItemize}

The {\bfseries{USART Basic}} driver provides basic USART functionality, that is\+:
\begin{DoxyItemize}
\item Transmission of a character
\item Reception of a character
\item Optional support for redirecting printf() output to USART
\end{DoxyItemize}

The USART Basic driver has four modes of operation\+:
\begin{DoxyItemize}
\item Asynchronous polled mode
\item Synchronous polled mode
\item Asynchronous interrupt-\/driven mode
\item Synchronous interrupt-\/driven mode
\end{DoxyItemize}\hypertarget{group__doc__driver__usart__basic_doc_driver_usart_basic_configuration}{}\doxysubsection{Driver Configuration}\label{group__doc__driver__usart__basic_doc_driver_usart_basic_configuration}
The USART Basic driver is configured using START. The user can choose from the four modes of operation (sync/async, polled/\+IRQ). START also allows the user to select desired baud rate, character size, number of stop bits, parity etc.

START allows the user to select whether or not to include support for redirecting printf() output to the USART. Enabling this feature adds appropriate API functionality so that printf() in the user code redirects to the USART TXD I/O pin.

START allows the user to select size of buffers used in IRQ driven mode, see \mbox{\hyperlink{group__doc__driver__usart__basic_doc_driver_usart_basic_irq}{IRQ mode}} for details.

If several USART hardware instances are available on the device, the user can select which USART instance the driver shall use.\hypertarget{group__doc__driver__usart__basic_doc_driver_usart_basic_functional}{}\doxysubsection{Functional Description}\label{group__doc__driver__usart__basic_doc_driver_usart_basic_functional}
\hypertarget{group__doc__driver__usart__basic_doc_driver_usart_basic_async}{}\doxysubsubsection{Async mode}\label{group__doc__driver__usart__basic_doc_driver_usart_basic_async}
When in asynchronous mode, the USART uses only the TXD and RXD I/O pins. The XCK I/O pin is not used. The receiver must be set up with the same baud rate as the transmitter in order to be able to receive data correctly.\hypertarget{group__doc__driver__usart__basic_doc_driver_usart_basic_sync}{}\doxysubsubsection{Sync mode}\label{group__doc__driver__usart__basic_doc_driver_usart_basic_sync}
When in synchronous mode, the USART uses the TXD, RXD and XCK I/O pins. The receiver uses the signal received on the XCK pin as a clock to sample data received on the RXD pin, and to clock data on the TXD pin. When synchronous mode is used, the XCK pin controls whether the transmission clock is input (slave mode) or output (master mode). The corresponding port pin must be set to output for master mode or to input for slave mode.\hypertarget{group__doc__driver__usart__basic_doc_driver_usart_basic_polled}{}\doxysubsubsection{Polled mode}\label{group__doc__driver__usart__basic_doc_driver_usart_basic_polled}
The polled mode version of the driver provides functions for transmitting and receiving one character of data. The read and write-\/functions are blocking\+: If the USART is not able to execute the desired operation immediately, the driver blocks until the operation has been performed.

Functions are provided to check if\+:
\begin{DoxyItemize}
\item a character has been received
\item the USART can accept a new character for transmission
\item the previous character has been completely transmitted out of the USART shift register
\end{DoxyItemize}

These functions can be used to check if the USART is ready to process a $<$component\+\_\+name$>$\+\_\+read() or $<$component\+\_\+name$>$\+\_\+write() immediately. In applications where blocking must be avoided, the user must check the status of the USART hardware and call the $<$component\+\_\+name$>$\+\_\+read() or $<$component\+\_\+name$>$\+\_\+write() only if they will not block.\hypertarget{group__doc__driver__usart__basic_doc_driver_usart_basic_irq}{}\doxysubsubsection{IRQ mode}\label{group__doc__driver__usart__basic_doc_driver_usart_basic_irq}
The IRQ modes of the basic driver has the same API as the polled modes. The difference is that the $<$component\+\_\+name$>$\+\_\+read() and $<$component\+\_\+name$>$\+\_\+write() functions access ringbuffers instead of the USART data registers directly. The Interrupt Service Routines provided by the driver transfers data between the ringbuffers and the USART hardware whenever the hardware is ready to accept it. The size of the RX and TX ringbuffers can be configured in START. The optimal setting of the buffer size is dependent on the desired baud rate.

The $<$component\+\_\+name$>$\+\_\+read() function will block if there is no data to be read in the RX ringbuffer. The $<$component\+\_\+name$>$\+\_\+write()-\/function will block there is no room for more data in the TX ringbuffer.

Functions are provided to check if\+:
\begin{DoxyItemize}
\item the RX ringbuffer contains received characters
\item the TX ringbuffer has room for a new character
\item the previous character has been completely transmitted out of the USART shift register
\end{DoxyItemize}

These functions can be used to check if the ringbuffers are ready to process a $<$component\+\_\+name$>$\+\_\+read() or $<$component\+\_\+name$>$\+\_\+write() immediately. In applications where blocking must be avoided, the user must check the status of the ringbuffers and call the $<$component\+\_\+name$>$\+\_\+read() or $<$component\+\_\+name$>$\+\_\+write() only if they will not block.\hypertarget{group__doc__driver__usart__basic_doc_driver_usart_basic_hardware}{}\doxysubsection{Hardware Dependencies}\label{group__doc__driver__usart__basic_doc_driver_usart_basic_hardware}
The USART Basic driver usually uses some sort of hardware that implements USART functionality, even though it is possible to impement a software USART implemented by bit-\/banging I/O pins.

Different MCUs have USART hardware with different names and functionalities, such as UART, USART, USI etc. In START, the user selects a device and adds the USART Basic driver. A device may have several possible hardware resources available for the driver, such as USART0, USART1 etc. In this case the user must select which one to use.

The configuration options in START displays options that are dependent on the hardware used to implement the USART driver. For example, an option may allow changing the baud rate used to drive the underlying USART hardware.\hypertarget{group__doc__driver__usart__basic_doc_driver_usart_basic_software}{}\doxysubsection{Software Dependencies}\label{group__doc__driver__usart__basic_doc_driver_usart_basic_software}
The interrupt-\/driven configurations use the interrupt functionality of the underlying USART hardware. Make sure that global interrupts are enabled (using sei()) and that the Interrupt Controller, if present, is configured so that any interrupts are serviced correctly.\hypertarget{group__doc__driver__usart__basic_doc_driver_usart_basic_code}{}\doxysubsection{Code example}\label{group__doc__driver__usart__basic_doc_driver_usart_basic_code}

\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <stdio.h>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <string.h>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <atmel\_start.h>}}
\DoxyCodeLine{}
\DoxyCodeLine{uint8\_t tx[16] = \textcolor{stringliteral}{"{}data"{}}; }
\DoxyCodeLine{uint8\_t rx[16];}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void} fail(\textcolor{keywordtype}{void});}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{void} fail()\{}
\DoxyCodeLine{    \textcolor{keywordflow}{while}(1);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{void})}
\DoxyCodeLine{\{}
\DoxyCodeLine{    uint8\_t i;}
\DoxyCodeLine{    }
\DoxyCodeLine{    \textcolor{comment}{/* Initializes MCU, drivers and middleware */}}
\DoxyCodeLine{    atmel\_start\_init();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// If USART Basic driver is in IRQ-\/mode, enable global interrupts.}}
\DoxyCodeLine{    sei();}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Test driver functions, assumes that the USART RX and }}
\DoxyCodeLine{    \textcolor{comment}{// TX pins have been loopbacked, or that USART hardware }}
\DoxyCodeLine{    \textcolor{comment}{// is configured in loopback mode}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Test printf() support}}
\DoxyCodeLine{    printf(\textcolor{stringliteral}{"{}hello"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Check that "{}hello"{} was received on loopback RX.}}
\DoxyCodeLine{    \textcolor{comment}{// Initialize rx buffer so strncmp() check will work}}
\DoxyCodeLine{    memset(rx, 0, \textcolor{keyword}{sizeof}(rx));}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (i=0;i<strlen(\textcolor{stringliteral}{"{}hello"{}});i++)}
\DoxyCodeLine{        rx[i]=\mbox{\hyperlink{group__doc__driver__usart__basic_ga52609b48c1fa65ca905d8cb91d641e13}{USART\_0\_read}}(); \textcolor{comment}{// Blocks until character is available}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// Compare received and expected data}}
\DoxyCodeLine{    \textcolor{keywordflow}{if} (strncmp(\textcolor{stringliteral}{"{}hello"{}}, (\textcolor{keywordtype}{char}*)rx, strlen(\textcolor{stringliteral}{"{}hello"{}})) != 0)}
\DoxyCodeLine{        fail();}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{// If we get here, everything was OK}}
\DoxyCodeLine{    printf(\textcolor{stringliteral}{"{}ok"{}});}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{comment}{/* Replace with your application code */}}
\DoxyCodeLine{    \textcolor{keywordflow}{while} (1) \{}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{group__doc__driver__usart__basic_gacb4743093fced48085f08be8475a110a}\label{group__doc__driver__usart__basic_gacb4743093fced48085f08be8475a110a}} 
\index{USART Basic@{USART Basic}!USART\_0\_disable@{USART\_0\_disable}}
\index{USART\_0\_disable@{USART\_0\_disable}!USART Basic@{USART Basic}}
\doxysubsubsection{\texorpdfstring{USART\_0\_disable()}{USART\_0\_disable()}}
{\footnotesize\ttfamily void USART\+\_\+0\+\_\+disable (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Disable USART\+\_\+0. 


\begin{DoxyEnumerate}
\item Disables the USART module by clearing the enable-\/bit(s) in the USART control register
\item If supported by the clock system, disables the clock to the USART
\end{DoxyEnumerate}

\begin{DoxyReturn}{Returns}
Nothing 
\end{DoxyReturn}
\mbox{\Hypertarget{group__doc__driver__usart__basic_ga2e9797ff138959ac3d036b53138b7614}\label{group__doc__driver__usart__basic_ga2e9797ff138959ac3d036b53138b7614}} 
\index{USART Basic@{USART Basic}!USART\_0\_enable@{USART\_0\_enable}}
\index{USART\_0\_enable@{USART\_0\_enable}!USART Basic@{USART Basic}}
\doxysubsubsection{\texorpdfstring{USART\_0\_enable()}{USART\_0\_enable()}}
{\footnotesize\ttfamily void USART\+\_\+0\+\_\+enable (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Enable RX and TX in USART\+\_\+0. 


\begin{DoxyEnumerate}
\item If supported by the clock system, enables the clock to the USART
\item Enables the USART module by setting the RX and TX enable-\/bits in the USART control register
\end{DoxyEnumerate}

\begin{DoxyReturn}{Returns}
Nothing 
\end{DoxyReturn}
\mbox{\Hypertarget{group__doc__driver__usart__basic_gaa511a2829531e83a6b8a2d9f4d92cd4d}\label{group__doc__driver__usart__basic_gaa511a2829531e83a6b8a2d9f4d92cd4d}} 
\index{USART Basic@{USART Basic}!USART\_0\_enable\_rx@{USART\_0\_enable\_rx}}
\index{USART\_0\_enable\_rx@{USART\_0\_enable\_rx}!USART Basic@{USART Basic}}
\doxysubsubsection{\texorpdfstring{USART\_0\_enable\_rx()}{USART\_0\_enable\_rx()}}
{\footnotesize\ttfamily void USART\+\_\+0\+\_\+enable\+\_\+rx (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Enable RX in USART\+\_\+0. 


\begin{DoxyEnumerate}
\item If supported by the clock system, enables the clock to the USART
\item Enables the USART module by setting the RX enable-\/bit in the USART control register
\end{DoxyEnumerate}

\begin{DoxyReturn}{Returns}
Nothing 
\end{DoxyReturn}
\mbox{\Hypertarget{group__doc__driver__usart__basic_ga79b9d691565110f7852ceeaf4e4ae935}\label{group__doc__driver__usart__basic_ga79b9d691565110f7852ceeaf4e4ae935}} 
\index{USART Basic@{USART Basic}!USART\_0\_enable\_tx@{USART\_0\_enable\_tx}}
\index{USART\_0\_enable\_tx@{USART\_0\_enable\_tx}!USART Basic@{USART Basic}}
\doxysubsubsection{\texorpdfstring{USART\_0\_enable\_tx()}{USART\_0\_enable\_tx()}}
{\footnotesize\ttfamily void USART\+\_\+0\+\_\+enable\+\_\+tx (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Enable TX in USART\+\_\+0. 


\begin{DoxyEnumerate}
\item If supported by the clock system, enables the clock to the USART
\item Enables the USART module by setting the TX enable-\/bit in the USART control register
\end{DoxyEnumerate}

\begin{DoxyReturn}{Returns}
Nothing 
\end{DoxyReturn}
\mbox{\Hypertarget{group__doc__driver__usart__basic_gac97a6770dcebe99ef4c8014c88d1bae2}\label{group__doc__driver__usart__basic_gac97a6770dcebe99ef4c8014c88d1bae2}} 
\index{USART Basic@{USART Basic}!USART\_0\_get\_data@{USART\_0\_get\_data}}
\index{USART\_0\_get\_data@{USART\_0\_get\_data}!USART Basic@{USART Basic}}
\doxysubsubsection{\texorpdfstring{USART\_0\_get\_data()}{USART\_0\_get\_data()}}
{\footnotesize\ttfamily uint8\+\_\+t USART\+\_\+0\+\_\+get\+\_\+data (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Get recieved data from USART\+\_\+0. 

\begin{DoxyReturn}{Returns}
Data register from USART\+\_\+0 module 
\end{DoxyReturn}
\mbox{\Hypertarget{group__doc__driver__usart__basic_gad3a251bba1a79346b1c27d3301767fc4}\label{group__doc__driver__usart__basic_gad3a251bba1a79346b1c27d3301767fc4}} 
\index{USART Basic@{USART Basic}!USART\_0\_init@{USART\_0\_init}}
\index{USART\_0\_init@{USART\_0\_init}!USART Basic@{USART Basic}}
\doxysubsubsection{\texorpdfstring{USART\_0\_init()}{USART\_0\_init()}}
{\footnotesize\ttfamily int8\+\_\+t USART\+\_\+0\+\_\+init (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Initialize USART interface If module is configured to disabled state, the clock to the USART is disabled if this is supported by the device\textquotesingle{}s clock system. 

\begin{DoxyReturn}{Returns}
Initialization status. 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em 0} & the USART init was successful \\
\hline
{\em 1} & the USART init was not successful \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{group__doc__driver__usart__basic_ga8389bcb949d1ff820c139bbda0f9abf6}\label{group__doc__driver__usart__basic_ga8389bcb949d1ff820c139bbda0f9abf6}} 
\index{USART Basic@{USART Basic}!USART\_0\_is\_rx\_ready@{USART\_0\_is\_rx\_ready}}
\index{USART\_0\_is\_rx\_ready@{USART\_0\_is\_rx\_ready}!USART Basic@{USART Basic}}
\doxysubsubsection{\texorpdfstring{USART\_0\_is\_rx\_ready()}{USART\_0\_is\_rx\_ready()}}
{\footnotesize\ttfamily bool USART\+\_\+0\+\_\+is\+\_\+rx\+\_\+ready (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Check if the USART has received data. 

\begin{DoxyReturn}{Returns}
The status of USART RX data ready check 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em true} & The USART has received data \\
\hline
{\em false} & The USART has not received data \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{group__doc__driver__usart__basic_ga97b8ccb4de88c69e8f128d05aacf3020}\label{group__doc__driver__usart__basic_ga97b8ccb4de88c69e8f128d05aacf3020}} 
\index{USART Basic@{USART Basic}!USART\_0\_is\_tx\_busy@{USART\_0\_is\_tx\_busy}}
\index{USART\_0\_is\_tx\_busy@{USART\_0\_is\_tx\_busy}!USART Basic@{USART Basic}}
\doxysubsubsection{\texorpdfstring{USART\_0\_is\_tx\_busy()}{USART\_0\_is\_tx\_busy()}}
{\footnotesize\ttfamily bool USART\+\_\+0\+\_\+is\+\_\+tx\+\_\+busy (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Check if USART\+\_\+0 data is transmitted. 

\begin{DoxyReturn}{Returns}
Receiver ready status 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em true} & Data is not completely shifted out of the shift register \\
\hline
{\em false} & Data completely shifted out if the USART shift register \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{group__doc__driver__usart__basic_gac3a937c744dab16200ee8db359f49080}\label{group__doc__driver__usart__basic_gac3a937c744dab16200ee8db359f49080}} 
\index{USART Basic@{USART Basic}!USART\_0\_is\_tx\_ready@{USART\_0\_is\_tx\_ready}}
\index{USART\_0\_is\_tx\_ready@{USART\_0\_is\_tx\_ready}!USART Basic@{USART Basic}}
\doxysubsubsection{\texorpdfstring{USART\_0\_is\_tx\_ready()}{USART\_0\_is\_tx\_ready()}}
{\footnotesize\ttfamily bool USART\+\_\+0\+\_\+is\+\_\+tx\+\_\+ready (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Check if the usart can accept data to be transmitted. 

\begin{DoxyReturn}{Returns}
The status of USART TX data ready check 
\end{DoxyReturn}

\begin{DoxyRetVals}{Return values}
{\em false} & The USART can not receive data to be transmitted \\
\hline
{\em true} & The USART can receive data to be transmitted \\
\hline
\end{DoxyRetVals}
\mbox{\Hypertarget{group__doc__driver__usart__basic_ga52609b48c1fa65ca905d8cb91d641e13}\label{group__doc__driver__usart__basic_ga52609b48c1fa65ca905d8cb91d641e13}} 
\index{USART Basic@{USART Basic}!USART\_0\_read@{USART\_0\_read}}
\index{USART\_0\_read@{USART\_0\_read}!USART Basic@{USART Basic}}
\doxysubsubsection{\texorpdfstring{USART\_0\_read()}{USART\_0\_read()}}
{\footnotesize\ttfamily uint8\+\_\+t USART\+\_\+0\+\_\+read (\begin{DoxyParamCaption}\item[{void}]{ }\end{DoxyParamCaption})}



Read one character from USART\+\_\+0. 

Function will block if a character is not available.

\begin{DoxyReturn}{Returns}
Data read from the USART\+\_\+0 module 
\end{DoxyReturn}
\mbox{\Hypertarget{group__doc__driver__usart__basic_gac62803942950806dd1663834efd2448d}\label{group__doc__driver__usart__basic_gac62803942950806dd1663834efd2448d}} 
\index{USART Basic@{USART Basic}!USART\_0\_write@{USART\_0\_write}}
\index{USART\_0\_write@{USART\_0\_write}!USART Basic@{USART Basic}}
\doxysubsubsection{\texorpdfstring{USART\_0\_write()}{USART\_0\_write()}}
{\footnotesize\ttfamily void USART\+\_\+0\+\_\+write (\begin{DoxyParamCaption}\item[{const uint8\+\_\+t}]{data }\end{DoxyParamCaption})}



Write one character to USART\+\_\+0. 

Function will block until a character can be accepted.


\begin{DoxyParams}[1]{Parameters}
\mbox{\texttt{ in}}  & {\em data} & The character to write to the USART\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Nothing 
\end{DoxyReturn}
